name: Shared Azure DevOps GEI Migration

on:
  workflow_call:
    inputs:
      TARGET_ORGANIZATION:
        description: 'The GitHub Enterprise Cloud organization to migrate to'
        required: true
        type: string
      RUNNER:
        description: 'The runner to use for all of the jobs in the workflow'
        type: string
        default: 'ubuntu-latest'
      INSTALL_PREREQS:
        description: 'If set to true, installs pre-requisites from apt, pwsh, and GEI'
        type: string
        default: 'true'
    secrets:
      TARGET_ADMIN_TOKEN:
        required: true
      SOURCE_ADMIN_TOKEN:
        required: true

permissions:
  contents: read
  issues: write

jobs:
  prepare:
    name: Prepare
    runs-on: ${{ inputs.RUNNER }}
    outputs:
      repositories: ${{ steps.json.outputs.repositories }}
      migration-type: ${{ steps.migration-type.outputs.result }}
      parsed-issue: ${{ steps.parse-issue-body.outputs.jsonString }}

    if: github.event_name == 'issue_comment' &&
      (contains(github.event.comment.body, '/run-dry-run-migration') ||
      contains(github.event.comment.body, '/run-production-migration'))

    steps:
      - name: Check out scripts
        uses: actions/checkout@v4

      - name: Parse issue body
        id: parse-issue-body
        uses: stefanbuck/github-issue-parser@v3

      - run: echo $JSON_STRING
        env:
          JSON_STRING: ${{ steps.parse-issue-body.outputs.jsonString }}

      - name: Set migration type
        uses: actions/github-script@v7
        id: migration-type
        with:
          result-encoding: string
          script: |
            return context.payload.comment.body.match('dry-run') ? 'Dry-run' : 'Production'

      - name: Build matrix
        uses: actions/github-script@v7
        id: json
        with:
          script: |
            let repositories = process.env.REPOSITORIES.replace(/\r/g, '').split('\n');
            let json = JSON.stringify(repositories);
            console.log(json);
            core.setOutput('repositories', json);
        env:
          REPOSITORIES: ${{ steps.parse-issue-body.outputs.issueparser_repositories }}

  migrate:
    name: GEI
    runs-on: ${{ inputs.RUNNER }}
    needs: prepare
    strategy:
      matrix: 
        repository: ${{ fromJson(needs.prepare.outputs.repositories) }}
      fail-fast: false
      max-parallel: 15

    # Maximize the timeout to 50,400 minutes (35 days) from the default
    # limit of 360 minutes (6 hours), as migrations can take some time.
    timeout-minutes: 50400

    steps:
      - name: Check out scripts
        uses: actions/checkout@v4

      - name: Install common dependencies
        if: ${{ inputs.INSTALL_PREREQS == 'true' || inputs.INSTALL_PREREQS == '' }}
        run: |
          sudo apt-get update
          sudo apt-get install --yes git unzip curl wget apt-transport-https software-properties-common

      - name: Install ado2gh
        if: ${{ inputs.INSTALL_PREREQS == 'true' || inputs.INSTALL_PREREQS == '' }}
        run: |
          if [ -z "$(command -v ado2gh)" ]
          then
            wget https://github.com/github/gh-ado2gh/releases/latest/download/ado2gh-linux-amd64
            sudo install --owner root --group root --mode 755 ado2gh-linux-amd64 /usr/local/bin/ado2gh
          fi

      - if: runner.debug
        name: GEI version number
        run: ado2gh --version

      - name: Install PowerShell
        if: ${{ inputs.INSTALL_PREREQS == 'true' || inputs.INSTALL_PREREQS == '' }}
        run: |
          if [ -z "$(command -v pwsh)" ]
          then
            wget "https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb"
            sudo dpkg --install packages-microsoft-prod.deb
            sudo apt-get update
            sudo apt-get install --yes powershell
          fi

      - if: runner.debug
        name: PowerShell version number
        run: pwsh --version

      - name: Create lock flag based on migration type
        uses: actions/github-script@v7
        id: lock-flag
        with:
          result-encoding: string
          script: |
            return '${{ needs.prepare.outputs.migration-type }}' === 'Production' ? '--lock-source-repo' : ''

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 16
      - run: |
          npm i octokit@2.1.0 fs
  
      - name: Migrate repositories
        shell: pwsh
        id: migrate
        run: |
          function Exec {
            param (
              [scriptblock]$ScriptBlock
            )
            & @ScriptBlock
            if ($lastexitcode -ne 0) {
              exit $lastexitcode
            }
          }

          function ExtractInfoFromUrl($url) {
              $uri = [System.Uri]$url
              $parts = $uri.AbsolutePath.Split("/", [System.StringSplitOptions]::RemoveEmptyEntries)

              if ($uri.Host -eq 'dev.azure.com') {
                  $global:AdoOrg = $parts[0]
                  $global:AdoTeamProject = $parts[1]
                  $global:RepoName = $parts[3]
              }
              elseif ($uri.Host.EndsWith('visualstudio.com')) {
                  $global:AdoOrg = $uri.Host.Split('.')[0]
                  $global:AdoTeamProject = $parts[0]
                  $global:RepoName = $parts[2]
              }
              else {
                  Write-Host "Unsupported URL format"
                  return
              }

              Write-Host "Org: $AdoOrg"
              Write-Host "Team Project: $AdoTeamProject"
              Write-Host "Repo Name: $RepoName"
          }

          function ExecAndGetMigrationID {
            param (
              [scriptblock]$ScriptBlock
            )
            $MigrationID = Exec $ScriptBlock | ForEach-Object {
              Write-Host $_
              $_
            } | Select-String -Pattern "\(ID: (.+)\)" | ForEach-Object { $_.matches.groups[1] }
            return $MigrationID
          }

          if ($Env:VISIBILITY -eq 'None') {
            $VisibilityValue = 'private'
          } else {
            $VisibilityValue = $Env:VISIBILITY.ToLower()
          }

          $RepoMigrations = [ordered]@{}
          $RepoSources = $Env:REPOSITORIES.Split("`n")

          foreach ($Repo in $RepoSources) {
            $Repo = $Repo.Trim()
            Write-Host "Repo: $Repo"

            ExtractInfoFromUrl "$Repo"

            if ("${{ needs.prepare.outputs.migration-type }}" -eq "production") {
              ado2gh lock-ado-repo `
                --ado-org $AdoOrg `
                --ado-team-project $AdoTeamProject `
                --ado-repo $RepoName
            }

            $MigrationID = ExecAndGetMigrationID {
              ado2gh migrate-repo `
              --ado-org $AdoOrg `
              --ado-team-project $AdoTeamProject `
              --ado-repo $RepoName `
              --github-repo $RepoName `
              --github-org '${{ inputs.TARGET_ORGANIZATION }}' `
              --target-repo-visibility $VisibilityValue `                                                     `
              --queue-only
            }
            
            if (!$null -eq $MigrationID) {
              Write-Host "Queued migration of repository $RepoName with ID $MigrationID"
              $RepoMigrations[$RepoName] = $MigrationID
            }
          }

          if ($RepoMigrations.count -eq 0) {
            Write-Host "No migrations were started. Exiting..."
            exit 1
          }

          Write-Host "Queued $($RepoMigrations.count) migration(s). Waiting for them to complete..."

          foreach ($RepoName in $RepoMigrations.Keys) {
            $MigrationID = $RepoMigrations[$RepoName]
            Write-Host "Waiting for migration of repository $RepoName with ID $MigrationID to complete..."

            ado2gh wait-for-migration --migration-id $MigrationID
          }

        env:
          GH_PAT: ${{ secrets.TARGET_ADMIN_TOKEN }}
          ADO_PAT: ${{ secrets.SOURCE_ADMIN_TOKEN }}
          REPOSITORIES: ${{ matrix.repository }}
          VISIBILITY: ${{ fromJson(needs.prepare.outputs.parsed-issue).target_repository_visibility }}

      - name: Reclaim mannequins
        run: |
          ado2gh reclaim-mannequin \
            --csv user-mappings-gei.csv \
            --github-org ${{ inputs.TARGET_ORGANIZATION }} \
            --github-pat ${{ secrets.TARGET_ADMIN_TOKEN }}

      - name: Write repo migration status
        if: always()
        id: write-status
        run: |
          reponame=$(basename ${{ matrix.repository }})
          echo "repo-name=$reponame" >> "$GITHUB_OUTPUT" 
          echo "${{ matrix.repository }}, ${{ job.status }}" > ${reponame}.txt

      - name: Upload repo migration status
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: migration-status-${{ steps.write-status.outputs.repo-name }}
          path: ${{ steps.write-status.outputs.repo-name }}.txt
          retention-days: 30

  generate-mannequins:
    name: Get Mannequins
    runs-on: ${{ inputs.RUNNER }}
    needs: [prepare, migrate]
    if: ${{ contains(github.event.comment.body, 'dry-run') && (failure() || success()) }}
    steps:
      - name: Install ado2gh
        if: ${{ inputs.INSTALL_PREREQS == 'true' || inputs.INSTALL_PREREQS == '' }}
        run: |
          if [ -z "$(command -v ado2gh)" ]
          then
            wget https://github.com/github/gh-ado2gh/releases/latest/download/ado2gh-linux-amd64
            sudo install --owner root --group root --mode 755 ado2gh-linux-amd64 /usr/local/bin/ado2gh
          fi

      - if: runner.debug
        name: ado2gh version number
        run: ado2gh --version

      - name: Generate user mapping file
        env:
          TARGET_ORGANIZATION: ${{ inputs.TARGET_ORGANIZATION }}
        run: |
          ado2gh generate-mannequin-csv \
          --output user-mappings-template.csv \
          --github-org ${{ env.TARGET_ORGANIZATION }} \
          --github-pat ${{ secrets.TARGET_ADMIN_TOKEN }}
  
      - name: Upload user mapping file to artifacts
        uses: actions/upload-artifact@v4
        with:
          name: user-mappings-template.csv
          path: ./user-mappings-template.csv
          if-no-files-found: error
          retention-days: 30

  report-failure:
    name: Report Failure
    runs-on: ${{ inputs.RUNNER }}
    needs: [prepare, migrate]
    if: failure()
    steps:
      - uses: actions/download-artifact@v4
        id: download-artifact
        with:
          pattern: migration-status-*
          path: migration-status
          merge-multiple: true
      - name: Get failed repositories
        id: get-failed-repos
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            let failedRepos = [];
            const dir = 'migration-status';

            fs.readdirSync(`./${dir}`).forEach(file => {
              if (path.extname(file) === '.txt') {
                let [repo, status] = fs.readFileSync(`${dir}/${file}`, 'utf-8').split(',');
                console.log(`Repo: ${repo}, Status: ${status}`);
                if (status.trim() !== 'success') {
                  failedRepos.push(repo);
                }
              }
            });

            console.log(`Failed repos: \n${failedRepos.join('\n')}`);
            core.setOutput('failed-repos', failedRepos.join('\n'));

      - name: Report failed migration
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const repositories = `${{ steps.get-failed-repos.outputs.failed-repos }}`;
            let body = `:no_entry: **${{ needs.prepare.outputs.migration-type }} migration failed.** [View workflow run for details](${context.payload.repository.html_url}/actions/runs/${context.runId})\n`

            if ('${{ steps.download-artifact.conclusion }}' === 'success') {
              body += `\n${repositories.trim().split('\n').length}/${process.env.REPOSITORIES.trim().split('\n').length} repo(s) failed: 
              \`\`\`
              ${{ steps.get-failed-repos.outputs.failed-repos }}
              \`\`\``

              const migrationType = '${{ needs.prepare.outputs.migration-type }}';
              const issueTitle = 'Azure+DevOps+to+GitHub+migration+%5BGEI%5D';
              const issueRepositories = repositories.replace(/\n/g, '%0A').replace(/ /g, '+');
              if (migrationType === 'Production' && repositories.trim().split('\n').length !== process.env.REPOSITORIES.trim().split('\n').length) {
                body += `\nSince this was a partially successful **${{ needs.prepare.outputs.migration-type }}** run, click [here](${context.payload.repository.html_url}/issues/new?template=gei-azure-devops-migration.yml&title=${issueTitle}&repositories=${issueRepositories}&labels=gei-azure-devops,migration) to create a new issue with the failed repo(s).`
              }
            }

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body
            })
        env:
          REPOSITORIES: ${{ fromJson(needs.prepare.outputs.parsed-issue).repositories }}

  report-success:
    name: Report Success
    runs-on: ${{ inputs.RUNNER }}
    needs: [prepare, migrate]
    if: success()
    steps:
      - name: Report successful migration
        uses: actions/github-script@v7
        with:
          script: |
            const body = `:tada: **${{ needs.prepare.outputs.migration-type }} migration succeeded.** [View workflow run for details](${context.payload.repository.html_url}/actions/runs/${context.runId})`
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body
            })

      - name: Add delete repositories comment
        uses: actions/github-script@v7
        with:
          script: |
            const migrationType = '${{ needs.prepare.outputs.migration-type }}'

            if (migrationType === 'Dry-run') {
              let body = `In order to delete the migrated repositories of the dry-run, add a comment with the following slash command:

              \`\`\`
              /delete-repositories
              \`\`\`
              `

              // remove leading whitespace
              body = body.replace(/  +/g, '')

              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body
              })
            }
